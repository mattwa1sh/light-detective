## **Light Detective: Detailed Technical Specification**

### **Summary**

Light Detective is a 2D browser-based puzzle game that challenges the user to reverse-engineer the placement of mirrors and a real object (ball) by matching the reflected virtual images shown on the screen.

The user drags a **blue ball** and mirror segments in an empty room to reproduce a hidden arrangement whose reflected virtual images are shown as **yellow ghost targets**. When the user’s reflections match the target set, everything turns **green**, and the level is solved.

------

### **Core Objects**

- **Ball**:
   A draggable circle (the “real” object) whose position generates reflected virtual images.
- **Mirror**:
   A draggable and rotatable line segment that reflects the ball’s position using the law of reflection (angle of incidence = angle of reflection).
- **Eye (Viewer)**:
   A fixed or optionally draggable point that represents the user’s point of view (for more advanced levels).
- **Virtual Images**:
   Computed positions generated by reflecting the ball across mirrors, shown as yellow ghost circles for targets, blue copies for user-generated images, and green when matched.

------

### **Game Workflow**

1. **Puzzle Generation (Behind the Scenes)**
   - Randomly position:
     - A real ball (x, y) inside a 2D rectangular room.
     - A set of mirror segments (2–4), each defined by two endpoints (x1, y1, x2, y2).
   - Run the **reflection engine**:
     - Compute the ball’s reflections across each mirror.
     - Recursively reflect new virtual images across additional mirrors up to:
       - A fixed recursion depth (e.g., 2–3 layers), **or**
       - A minimum visual size threshold.
   - Save the positions and sizes of all reflected images (these become the **yellow ghost targets**).
   - Discard the original arrangement (this forces the user to figure it out).
2. **User Interaction**
   - Display the yellow ghost targets (fixed).
   - Allow the user to:
     - Drag and position the blue ball.
     - Drag, rotate, and place mirrors.
   - On every user action:
     - Re-run the **reflection engine** using the user’s current arrangement.
     - Generate **blue reflections** and compare their positions to the yellow targets.
     - If a blue reflection matches a yellow target (within a pixel tolerance), highlight it **green**.
     - If all yellow targets are matched, trigger a **level complete** state.
3. **Feedback**
   - Live visual overlay:
     - Yellow = target image.
     - Blue = user-generated reflection.
     - Green = correct match.
   - Optional:
     - Display a “success” banner or allow the user to proceed to the next puzzle.

------

### **Geometry & Math**

- Mirrors are modeled as infinite or bounded 2D line segments.
- Use vector math or reflection formulas to:
  - Calculate the virtual (mirror) point of any object relative to the mirror line.
  - Apply recursive reflections across multiple mirrors.
  - Apply a size scaling factor for each deeper reflection (optional, for visual clarity).

------

### **Technical Stack**

✅ **Language:** JavaScript (or TypeScript)
 ✅ **Rendering:** HTML5 Canvas (or p5.js for rapid prototyping)
 ✅ **Libraries:** Optional vector math helpers (e.g., `gl-matrix` or p5.Vector)
 ✅ **Hosting:** Static web page (GitHub Pages, Netlify, etc.)

------

### **File Structure**

```
swift


CopyEdit
/light-detective/
├── index.html           (HTML shell, loads scripts)
├── sketch.js            (main logic & drawing)
├── reflection.js        (reflection engine & helpers)
├── style.css            (optional minimal styles)
├── assets/              (optional, e.g., textures or sounds)
```

------

### **Core Components / Modules**

1. **Ball Class**
   - Properties: `x`, `y`, `radius`
   - Methods:
     - `show()` → draw on canvas.
     - `setPosition(x, y)` → update on drag.
2. **Mirror Class**
   - Properties: `x1`, `y1`, `x2`, `y2`, `angle`
   - Methods:
     - `show()` → draw on canvas.
     - `rotate(theta)` → adjust angle.
     - `move(dx, dy)` → adjust position.
3. **Reflection Engine**
   - Inputs:
     - Ball position.
     - Set of mirrors.
     - Max recursion depth.
   - Outputs:
     - Array of reflected virtual image positions and sizes.
   - Logic:
     - For each mirror:
       - Compute reflected point.
       - For each new virtual point, reflect again across remaining mirrors (recursively).
     - Stop at recursion limit or size threshold.
4. **Matching Engine**
   - Compares user-generated virtual images to stored target set.
   - Returns:
     - Matched/unmatched status for each target.
5. **UI**
   - Drag-and-drop handlers for ball and mirrors.
   - Visual feedback (color coding).
   - Level control (load next, reset, etc.).

------

### **Implementation Phases**

1. Build basic canvas with ball + mirrors → show positions.
2. Write reflection function for single mirror.
3. Extend to handle recursive multi-mirror reflections.
4. Build comparison + matching logic.
5. Add drag-and-drop controls.
6. Add win condition + feedback.
7. Polish UI + prep deliverables.

------

### **Constraints & Simplifications**

✅ Use circles (balls), not directional sprites, to avoid orientation headaches.
 ✅ Cap recursion depth to avoid infinite corridors.
 ✅ Snap mirrors to fixed lengths or angle increments to reduce user fiddliness.
 ✅ Use pixel-based tolerance (e.g., ±5px) for reflection matching.